{
    "template":{
        "prefix":"template",
        "body":[
            " #include \"bits/stdc++.h\" ",
" #include <ext/pb_ds/assoc_container.hpp>",
" #include <ext/pb_ds/tree_policy.hpp> ",
" using namespace std;",
" using namespace __gnu_pbds;",
" #define int              long long",
" #define ps(x,y)         fixed<<setprecision(y)<<x //how much precision is required",
" #define max(x,y)        ((x>y)?x:y)",
" #define min(x,y)        ((x<y)?x:y)",
" #define ff              first",
" #define ss              second",
" #define pb              push_back",
" #define eb              emplace_back",
" #define mp              make_pair",
" #define vi              vector<int>",
" #define vvi             vector<vector<int>>",
" #define pii             pair<int,int>",
" #define all(x)          x.begin(), x.end()",
" #define mem1(a)           memset(a,-1,sizeof(a))",
" #define mem0(a)           memset(a,0,sizeof(a))",
" #define loop(i,a,b)           for(int i=(int)a;i<(int)b;++i)",
" #define bloop(i,a,b)          for(int i=(int)a;i<=(int)b;++i)",
" #define loopr(i,a,b)          for(int i=(int)a;i>=(int)b;--i)",
" #define setbits(x)      __builtin_popcountll(x)",
" #define zrobits(x)      __builtin_ctzll(x)",
" #define uniq(v)           (v).erase(unique(all(v)),(v).end())",
" #define PI 3.1415926535897932384626",
" const int mod = 1000000007;",
" #define debug1(x) cout<<#x<<\" \"<<x<<endl;",
" #define debug2(x,y) cout<<#x<<\" \"<<x<<\" \"<<#y<<\" \"<<y<<endl;",
" #define debug3(x,y,z) cout<<#x<<\" \"<<x<<\" \"<<#y<<\" \"<<y<<\" \"<<#z<<\" \"<<z<<endl;",
" #define debug4(x,y,z,p) cout<<#x<<\" \"<<x<<\" \"<<#y<<\" \"<<y<<\" \"<<#z<<\" \"<<z<<\" \"<<#p<<endl;",
" int modpow(int a, int b, int mod) { int res = 1; for (; b; b >>= 1) { if (b & 1)res = res * a; res %= mod; a = a * a; a %= mod; }return res; }",
" int p(int a, int b) { int res = 1; for (; b; b >>= 1) { if (b & 1)res = res * a; a = a * a; }return res; }",
" typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> pbds; ",
" void ash(){",
"ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
"#ifndef ONLINE_JUDGE",
"   freopen(\"in.txt\", \"r\", stdin);",
"   freopen(\"out.txt\", \"w\", stdout);",
"    #endif ",
" }",
" int countDigit(long long n) {",
"   return floor(log10(n) + 1);",
" }",
" void solve(){",





" }",
" int32_t main()",
" {",
"//ash();",
"int t=1;",
"cin>>t;",
"while(t--){",
"solve();",
"}",
"return 0;",

    
" }",            
        ]
    },
    "Check if a number if power of 2 or not":{
        "prefix":"powerof2",
        "body":[
            "bool isPowerof2(int n){",
                "return (!n&(n-1) && n);",
            "}"
        ],
        "description": "to check if a number is power of 2 or not"
    },
    "bfs traversal of graph":{
        "prefix":"bfs",
        "body":[

            "void bfsUtil(vector<vector<int>> &adj,int i,int v,int e,vector<bool> &visited)",
            "{",
                "queue<int> q;",
                "q.push(i);",
                "visited[i]=true;",
                "cout<<i<<\" \";",
                "while(!q.empty())",
                "{",
                    "int temp=q.front();",
                    "q.pop();",
                    "cout<<temp<<\" \";",
                    "for(auto it=adj[temp].begin();it!=adj[temp].end();it++)",
                    "{",
                        "if(visited[*it]==false)",
                        "{",
                            "q.push(*it);",
                            "visited[*it]=true;",
                        "}",
                    "}",
                "}",
            "}",

            "void bfs(vector<vector<int>> adj,int v,int e)",
            "{",
                "vector<bool> visited(v,false);",
                "for(int i=0;i<v;i++)",
                "if(!visited[i])",
                "bfsUtil(adj,i,v,e,visited);",
            "}"
        ],
        "description": "it prints the bfs traversal of the graph if the graph is given in adjacency list."
    },

    "dfs traversal of graph":{
        "prefix":"dfs",
        "body": [

            "void dfsUtil(vector<vector<int>> adj,int i,int v,int e)",
            "{",
                 "cout<<i<<\" \";",
                 "visited[i]=true;",
                 "for(auto it=adj[temp].begin();it!=adj[temp].end();it++)",
                 "{",
                     "if(visited[*it]==false)",
                     "dfsUtil(adj,*it,v,e,visited);",
                 "}",
            "}",

            "void dfs(vector<vector<int>> adj,int v,int e)",
            "{",
                "vector<bool> visited(v,false);",
                "for(int i=0;i<v;i++)",
                "if(!visited[i])",
                "dfsUtil(adj,i,v,e,visited);",
            "}"
        ],
        "description": "it gives the dfs traversal of the graph provided the graph in adjacency list and the no of vertices and edges"
    },
    "Detect Cycle in Undirected":{
        "prefix":"detectCycleinUndirected",
        "body": [

            "int findd(vector<int> &parent,int i)",
            "{",
                "return parent[i]<0 ? i:parent[i]=findd(parent,parent[i]);",
            "}",

            "void unionn(vector<int> &parent,int x,int y)",
            "{",
                "if(parent[x]>parent[y])",
                "swap(x,y);",
                "parent[x]+=parent[y];",
                "parent[y]=x;",
            "}",

            "bool findCycle(vector<pair<int,int>> adj,int v,int e)",
            "{",
                "vector<int> parent(v,-1);",
                "for(int i=0;i<e;i++)",
                "{",
                    "int x=findd(parent,adj[i].first);",
                    "int y=findd(parent,adj[i].second);",
                    "if(x!=y)",
                    "{",
                        "unionn(parent,x,y)",
                    "}",
                    "else{",
                        "return 0;",
                    "}",
                "}",
                "return 1;",
            "}",
        ],
        "description": "detect whether the undirected graph contains cycle or not provided the graph as an array of edges (vector of pairs) , vertices, edges"
    },
    "Detect Cycle in Directed":{
        "prefix":"detectCycleinDirected",
        "body": [

            "bool isCycleUtil(vector<vector<int>> &adj,vector<int> &visited,vector<int> &recStack,int i)",
            "{",
                "if(visited[i]==false)",
                "{",
                    "visited[i]=true;",
                    "recStack[i]=true;",
                    "for(auto it=adj[i].begin();it!=adj[i].end();it++){",
                        "if(recStack[*it])",
                        "return true;",
                        "else if(!visited[*it] && isCycleutil(adj,visited,recStack,*it))",
                        "return true;",
                    "}",
                "}",
                "recStack[i]=false;",
                "return false;",
            "}",

            "bool isCycle(vector<vector<int>> &adj,int v,int e)",
            "{",
                "vector<int> visited(v,false);",
                "vector<int> recStack(v,false);",
                "for(int i=0;i<v;i++){",
                    "if(isCycleUtil(adj,visited,recStack,i))",
                    "return 1;",
                "}",
                "return 0;",
            "}",
        ]
    },
    "kruskal minimum spanning tree":{
            "prefix":"kruskal",
            "body":[
                "int findd(vector<int> &parent,int i){",
                    "return parent[i]<0 ? i:parent[i]=findd(parent,parent[i]);",
                "}",

                "void unionn(vector<int> &parent,int x,int y)",
                "{",
                    "if(parent[x]>parnet[y])",
                    "swap(x,y);",
                    "parent[x]+=parnet[y];",
                    "parnet[y]=x;",
                "}",

                "int mst(vector<pair<pair<int,int>>> adj,int v,int e){",
                    "int ans=0;",
                    "vector<int> parnet(v,-1);",
                    "sort(adj.begin(),adj.end());",
                    "for(int i=0;i<e;i++){",
                        "int from=adj[i].second.first;",
                        "int to=adj[i].second.second;",
                        "int w=adj[i].first;",
                        "int x=findd(parent,from);",
                        "int y=findd(parent,to);",
                        "if(x!=y)",
                        "{",
                            "ans+=w;",
                            "unionn(parent,x,y);",
                        "}",
                    "}",
                    "return ans;",
                "}",
            ],
            "desciption":"to find the minimum spanning tree of a graph provided(graph as pair of pair {weight,{from,to}}) ,vertices,edges",
        },
            "prims minimum spanning tree":{
                "prefix":"prims",
                "body":[

                    "int findd(vector<bool> &mstSet,vector<int> &dist){",
                        "int mini=INT_MAX,vertex;",
                        "for(int i=0;i<dist.size();i++){",
                            "if(dist[i]<mini && mstSet[i]==false){",
                                "mini=dist[i];",
                                "vertex=i;",
                            "}",
                        "}",
                        "return vertex;",
                    "}",

                    "int mst(vector<vector<int>> &adj,int v,int e)",
                    "{",
                        "vector<int> dist(v,INT_MAX);",
                        "vector<int> parent(v);",
                        "vector<bool> mstSet(v,false);",
                        "dist[0]=0;",
                        "parent[0]=-1;",
                        
                        "for(int i=0;i<v-1;i++)",
                        "{",
                            "int vertex=findd(mstSet,dist);",
                            "mstSet[vertex]=true;",
                            "for(int j=0;j<v;j++){",
                                "if(adj[vertex][j]!=0 && mstSet[j]==false && dist[j]>adj[vertex][j])",
                                "{",
                                    "dist[j]=adj[vertex][j];",
                                    "parent[j]=vertex;",
                                "}",
                            "}",
                        "}",
                        "int ans=0;",
                        "for(int i=1;i<v;i++){",
                            "ans+=adj[parent[i]][i];",
                        "}",
                        "return ans;",
                    "}",
                ],
                "description": "to find the minimum spanning tree using prims algo provided (graph as adjacency matrix ,vertices and edges)",
            },
            "finding the shortest path from given source to all nodes":{
                "prefix":"dijkstra",
                "body": [
                    "vector<int> dijkstra(vector<vector<int>> adj,int v,int e,int src){",
                        "vector<int> dist(v,INT_MAX);",
                        "set<pair<int,int>> s;",
                        "dist[src]=0;",
                        "s.insert({0,src});",
                        "while(!s.empty())",
                        "{",
                            "pair<int,int> temp=*s.begin();",
                            "s.erasae(s.begin());",
                            "int w=temp.first;",
                            "int from=temp.second;",
                            "for(auto it=adj[from].begin();it!=adj[from].end();it++)",
                            "{",
                                "int to=(*it).first;",
                                "int w2=(*it).second;",
                                "if(dist[to]>dist[from]+w2)",
                                "{",
                                    "if(dist[to]!=INT_MAX)",
                                    "s.erase(s.find({dist[to],to}));",
                                    "dist[to]=dist[from]+w2;",
                                    "s.insert({dist[to],to});",
                                "}",
                            "}",
                        "}",
                        "return dist;",
                    "}",
                ],
                "description": ""
            },

            "bellmann ford algo to detect negative edge wt. cycle":{
                "prefix":"bellmann ford",
                "body": [
                    "vector<int> bellmann(vector<pair<pair<int,int>>> &adj,int v,int e,int src)",
                    "{",
                        "vector<int> dist(v,INT_MAX);",
                        "vector<int> parent(v);",
                        "dist[src]=0;",
                        "parent[src]=-1;",
                        "for(int i=0;i<v-1;i++)",
                        "{",
                            "bool updated=false;",
                            "for(int i=0;i<e;i++)",
                            "{",
                                "int from=adj[i].second.first;",
                                "int to=adj[i].second.second;",
                                "int w=adj[i].first;",
                                "if(dist[from]!=INT_MAX && dist[from]+w<dist[to])",
                                "{",
                                    "dist[to]=dist[from]+w;",
                                    "parent[to]=from;",
                                    "updated=true;",
                                "}",
                            "}",
                            "if(updated==false)",
                            "break;",
                        "}",
                        "if(updated==true)",
                        "{",
                            "for(int i=0;i<e;i++)",
                            "{",
                                "int from=adj[i].second.first;",
                                "int to=adj[i].second.second;",
                                "int w=adj[i].first;",
                                "if(dist[from]!=INT_MAX && dist[from]+w<dist[to])",
                                "{",
                                    "cout<<\"negative edge wt. cycle found\"<<endl;",
                                    "break;",
                                "}",
                            "}",
                        "}",
                        "return dist;",
                    "}",
                ],
                "description": ""
            },

            "to find the number of connected components":{
                "prefix":"kosaraju",
                "body": [

                    "void dfs1(int i,vector<vector<int>> &adj,vector<bool> &visited,stack<int> &s)",
                    "{",
                        "visited[i]=true;",
                        "for(auto it=adj[i].begin();it!=adj[i].end();it++)",
                        "{",
                            "if(!visited[*it])",
                            "dfs1(*it,adj,visited,s);",
                        "}",
                        "s.push(i);",
                    "}",

                    "void dfs2(int i,vector<vector<int>> &adj,vector<bool> &visited)",
                    "{",
                        "visited[i]=true;",
                        "for(auto it=adj[i].begin();it!=adj[i].end();it++)",
                        "{",
                            "if(!visited[*it])",
                            "dfs1(*it,adj,visited,s);",
                        "}",
                    "}",

                    "int kosaraju(vector<vector<int>> adj,vector<vector<int>> adjt,int v,int e)",
                    "{",
                        "vector<bool> visited(v,false);",
                        "stack<int> s;",
                        "for(int i=0;i<v;i++)",
                        "{",
                            "if(!visited[i])",
                            "dfs1(i,adj,visited,s);",
                        "}",
                        "vector<bool> visited1(v,false);",
                        "int ans=0;",
                        "while(!s.empty())",
                        "{",
                            "int from=s.top();",
                            "s.pop();",
                            "if(!visited[from])",
                            "{",
                                "ans++;",
                                "dfs2(from,adjT,visited1);",
                            "}",
                        "}",
                        "return ans;",
                    "}",
                ],
                "description": ""
            },


            "to find the number of connected components in an efficient manner":{
                "prefix":"tarjan",
                "body": [

                    "void sol_tar(vector<vector<int>> &adj,vector<int> &dist,vector<int> &low,vector<bool> &inStack,stack<int> &myStack,int u)",
                    "{",
                        "static int time=0;",
                        "dist[u]=time;",
                        "low[u]=time;",
                        "time++;",
                        "inStack[u]=true;",
                        "myStack.push(u);",

                        "for(int v:adj[u])",
                        "{",
                            "if(dist[v]==-1)",
                            "{",
                                "sol_tar(adj,dist,low,inStack,myStack,v);",
                                "low[u]=min(low[u],low[v]);",
                            "}",
                            "else if(inStack[v])",
                            "{",
                                "low[u]=min(low[u],dist[v]);",
                            "}",
                        "}",

                        "if(low[u]==dist[u])",
                        "{",
                            "while(myStack.top()!=u)",
        "{",
            "cout<<myStack.top()<<\" \";",
            "instack[myStack.top()]=false;",
            "myStack.pop();",
        "}",
        "cout<<myStack.top()<<\" \";",
        "cout<<endl;",
        "instack[myStack.top()]=false;",
        "myStack.pop();",
                        "}",
                    "}",

                    "void tarjan(vector<vector<int>> &adj,int v,int e)",
                    "{",
                        "vector<int> dist(v,-1),low(v,-1);",
                        "vector<bool> inStack(v,false);",
                        "stack<int> myStack;",
                        
                        "for(int i=0;i<v;i++)",
                        "{",
                            "if(dist[i]==-1)",
                            "sol_tar(adj,dist,low,inStack,myStack,i);",
                        "}",
                        "return ;",
                    "}",
                ],
                "description": ""
            },

            "to find the vertex which after removal makes the graph disconnected":{
                "prefix": "articulation_point",
                "body": [


                    "void sol_articulation(vector<vector<int>> &adj,vector<int> &dist,vector<int> &low,vector<int> &parent,vetor<bool> &articulation,int u)",
                    "{",
                        "static int time=0;",
                        "dist[u]=time;",
                        "low[u]=time;",
                        "time++;",
                        "int children=0;",
                        

                        "for(int v:adj[u])",
                        "{",
                            "if(dist[v]==-1)",
                            "{",
                                "children++;",
                                "parent[v]=u;",
                                "sol_tar(adj,dist,low,inStack,myStack,v);",
                                "low[u]=min(low[u],low[v]);",
                                "if(parent[u]==-1 && children>1)",
                                "{",
                                    "articulation[u]=true;",
                                "}",
                                "else if(parent[u]!=-1 && low[v]>=dist[u])",
                                "articulation[u]=true;",
                            "}",
                            "else if(v!=parent[u])",
                            "{",
                                "low[u]=min(low[u],dist[v]);",
                            "}",
                        "}",

                    "}",


                    "vector<int> articulation_points(vector<vector<int>> &adj,int v,int e)",
                    "{",
                        "vector<int> dist(v,-1),low(v,-1);",
                        "vector<int> parent(v,-1);",
                        "vector<bool> articulation(v,false);",
                        
                        "for(int i=0;i<v;i++)",
                        "{",
                            "if(dist[i]==-1)",
                            "sol_tar(adj,dist,low,parent,articulation,i);",
                        "}",
                        "return articulation;",
                    "}",
                ],
                "description": ""
            },

            "to find an edge which after removal makes the graph disconnected":{
                "prefix":"bridge",
                "body": [

                    "void sol_articulation(vector<vector<int>> &adj,vector<int> &dist,vector<int> &low,vector<int> &parent,vetor<vector<int>> &bridges,int u)",
                    "{",
                        "static int time=0;",
                        "dist[u]=time;",
                        "low[u]=time;",
                        "time++;",

                        "for(int v:adj[u])",
                        "{",
                            "if(dist[v]==-1)",
                            "{",
                                "parent[v]=u;",
                                "sol_tar(adj,dist,low,inStack,myStack,v);",
                                "low[u]=min(low[u],low[v]);",
                                "if(low[v]>dist[u])",
                                "bridges.push_back(vector<int>{u,v});",
                            "}",
                            "else if(v!=parent[u])",
                            "{",
                                "low[u]=min(low[u],dist[v]);",
                            "}",
                        "}",

                    "}",


                    "vector<vector<int>> solve(vector<vector<int>> &adj,int v,int e)",
                    "{",
                        "vector<int> dist(v,-1),low(v,-1);",
                        "vector<int> parent(v,-1);",
                        "vector<vector<int>> bridges;",
                        
                        "for(int i=0;i<v;i++)",
                        "{",
                            "if(dist[i]==-1)",
                            "sol_bri(adj,dist,low,parent,bridges,i);",
                        "}",
                        "return bridges;",
                    "}",
                ],
                "description": ""
            },


            /** ----------------------------Linked List----------------------------------------------*/

            "template for linked list":{
                "prefix":"template",
                "body": [
                    "struct Node",
                    "{",
                        "public:",
                        "int data;",
                        "Node *next;",
                        "Node(int x)",
                        "{",
                            "data=x;",
                            "next=NULL;",
                        "}",
                    "}",
                ],
                "description": ""
            },

            "add at end of linked list":{
                "prefix":"addAtEnd",
                "body": [
                    "Node *addAtEnd(Struct Node *head,int num)",
                    "{",
                        "Node *node=new Node(num);",
                        "if(head==NULL)",
                        "{",
                            "head=node;",
                            "return head;",
                        "}",

                        "Node *curr=head;",
                        "while(curr->next!=NULL)",
                        "curr=curr->next;",
                        "cur->next=head;",

                        "return head;",
                    "}",
                ],
                "description": ""
            },

            "add at front of linked list":{
                "prefix": "addAtFront",
                "body": [
                    "Node *addAtFront(struct Node *head,int num)",
            "{",
                "Node *node=new Node(num);",
                "node->next=head;",
                "head=node;",
                "return head ;",
            "}",
                ],
                "description": ""
            },

            "add at specific position of linked list":{
                "prefix":"addAtPos",
                "body": [
                    "Node *insertatPos(Node *head,int pos,int n)",
"{",
    "Node *node=new Node(n);",
    "if(pos==1)",
    "{",
        "node->next=head;",
        "head=node;",
        "return head;",
    "}",
    
    "Node *curr=head;",
    "for(int i=1;i<=pos-2;i++)",
    "{",
        "curr=curr->next;",
    "}",

    "node->next=curr;",
    "curr->next=node;",

    "return head;",
"}",
                ],
                "description": ""
            },

            "delete the linked list of given value":{
                "prefix": "deleteAtKey",
                "body": [
                    "Node *deleteKey(Node *head,int key)",
"{",
    "Node *curr=head;",

    "if(curr->data==key)",
    "{",
        "curr=curr->next;",
        "head=curr;",
        "return head;",
    "}",

    "Node *prev=NULL;",
    "while(curr!=NULL && curr->data!=key)",
    "{",
        "prev=curr;",
        "curr=curr->next;",
    "}",
    "if(curr==NULL) {",
        "cout<<\"Key Not Found\"<<endl;",
        "return head;",
    "}",
    "prev->next=curr->next;",

    "return head;",
"}",
                ],
                "description": ""
            },

            "delete at specific position of linked list":{
                "prefix": "deleteAtPos",
                "body": [
                    "Node *deletePos(Node *head,int pos)",
"{",
    "Node *curr=head;",
    "if(pos==1)",
    "{",
        "curr=curr->next;",
        "head=curr;",
        "return head;",
    "}",

    "Node *prev=head;",

    "for(int i=1;i<=pos-1;i++)",
    "{",
        "prev=curr;",
        "curr=curr->next;",
    "}",

     "prev->next=curr->next;",

     "return head;",  
 
"}",
                ],
                "description": ""
            },

            "length of linked list":{
                "prefix": "length",
                "body": [
                    "int length(Node *head)",
"{",
    "Node *curr=head;",
    "int cnt=0;",
    "while(curr!=NULL)",
    "{",
        "cnt++;",
        "curr=curr->next;",
    "}",
    "return cnt;",
"}",
                ],
                "description": ""
            },

            "search a particular element in a linked list":{
                "prefix": "search",
                "body": [
                    "int search(Node *head,int key)",
"{",
    "if(head==NULL)",
    "return -1;",

    "Node *curr=head;",
    "int indx=1;",
    "while(curr->data!=key){",
        "curr=curr->next;",
        "indx++;",
    "}",
    "if(curr==NULL) return -1;",
    "return indx;",
"}",
                ],
                "description": ""
            },

            "print linked List":{
                "prefix": "print",
                "body": [
                    "void printList(Node *head)",
"{",
    "Node *tmp=head;",
    "if(!tmp) cout<<\"o\"<<endl;",
    "while(tmp!=NULL)",
    "{",
        "cout<<tmp->data<<\" \";",
        "tmp=tmp->next;",
    "}",
    "cout<<endl;",
    "return ;",
"}",
                ],
                "description": ""
            },

            "to print the Nth node from the start":{
                "prefix": "nthfromStart",
                "body": [
                    "int NthNodeStart(Node *head,int n)",
"{",
    "int indx=1;",
    "Node *curr=head;",
    "while(indx!=n)",
    "{",
        "curr=curr->next;",
        "indx++;",
    "}",
    "return curr->data;",
"}",
                ],
                "description": ""
            },

            "to print the Nth node from the end":{
                "prefix": "nthfromEnd",
                "body": [
                    "int NthNodeEnd(Node *head,int n)",
"{",
    "Node *curr=head;",
    "int len=0;",
    "while(curr!=NULL)",
    "{",
        "curr=curr->next;",
        "len++;",
    "}",
    "if(n>len) return -1;",
    "curr=head;int indx=1;",
    "while(indx!=(n-len+1))",
    "{",
        "indx++;curr=curr->next;",
    "}",

    "return curr->data;",
"}",
                ],
                "description": ""
            },

            

            

            /**-----------------------------------------------------------------------------------------------------------------------------------------------------*/
/**                                                     Sorting Algorithms                                                */
"bubble sort":{
    "prefix":"bubbleSort",
    "body":[
        "void bubbleSort(vector<int> &a){",
        "int n=a.size();",

 " for(int i=0;i<n-1;i++)",
 "{",
   "  int flag=0;",
   " for(int j=0;j<n-i-1;j++){",
   "  if(a[j]>a[j+1]){",
   "   swap(a[j],a[j+1]);",
   "  ++flag;",
 "}",

  "}",
"if(flag==0) break;",
 "}",
  "for(int i=0;i<a.size();i++){",
 " cout<<a[i]<<\" \";",
 "}",
 "}",

    ],
    "description": "Sort array using bubble sort",
},

"selection sort":{
    "prefix":"selectionSort",
    "body":[
        "void selectionSort(vector<int> &a){",
"    int n=a.size();",
"    for(int i = 0; i < n; i++){",
"        int min_ind = i;",    
"        for(int j = i + 1; j < n; j++){",
"            if(a[j] < a[min_ind]){",
"                min_ind = j;",
"            }",
"        }",    
"        swap(a[i], a[min_ind]);",
"    }",
"    for(int i=0;i<a.size();i++){",
"  cout<<a[i]<<\" \";",
"}",
"}",


    ],
    "description": "Sort array using selection sort",
},

"Insertion sort":{
    "prefix":"insertionSort",
    "body":[
        "void iSort(vector<int>&a){",
"   int n=a.size();",
"   for(int i=1;i<n;i++){",
"       int key = a[i];",
"        int j=i-1;",
"        while(j>=0 && a[j]>key){",
"            a[j+1]=a[j];",
"            j--;",
"        }",
"        a[j+1]=key;",
"    }",
"        for(int i=0;i<a.size();i++){",
"  cout<<a[i]<<\" \";",
"}",
"}",

    ],
    "description": "Sort array using Insertion sort",
},

"Merge sort":{
    "prefix":"mergeSort",
    "body":[
        "void merge(int arr[], int l, int m, int h){",
"    int n1=m-l+1, n2=h-m;",
"    int left[n1],right[n2];",
"    for(int i=0;i<n1;i++)",
"        left[i]=arr[i+l];",
"    for(int j=0;j<n2;j++)",
"        right[j]=arr[m+1+j];",    
"    int i=0,j=0,k=l;",
"    while(i<n1 && j<n2){",
"        if(left[i]<=right[j])",
"            arr[k++]=left[i++];",
"        else",
"            arr[k++]=right[j++];",
"    }",
"    while(i<n1)",
"        arr[k++]=left[i++];",
"    while(j<n2)",
"        arr[k++]=right[j++];    ",
"}",
"void mergeSort(int arr[],int l,int r){",
"    if(r>l){",
"        int m=l+(r-l)/2;",
"        mergeSort(arr,l,m);",
"       mergeSort(arr,m+1,r);",
"      merge(arr,l,m,r);",
"   }",
"}",

    ],
    "description": "Sort array using Merge sort",
},

"Quick sort":{
    "prefix":"quickSort",
    "body":[
        "#include <bits/stdc++.h>",
"using namespace std;",
"int partition(int arr[], int l, int h)",
"{   ",
 "   int pivot=arr[l];",
 "   int i=l-1,j=h+1;",
 "   while(true){",
 "       do{",
 "           i++;",
 "       }while(arr[i]<pivot);",
 "       do{",
 "           j--;",
 "       }while(arr[j]>pivot);",
 "       if(i>=j)return j;",
"        swap(arr[i],arr[j]);",
 "   }",
"}",
"void qSort(int arr[],int l,int h){",
 "   if(l<h){",
 "       int p=partition(arr,l,h);",
 "       qSort(arr,l,p);",
"       qSort(arr,p+1,h);",
"    }",
"}",

    ],
    "description": "Sort array using Quick sort",
},

"Heap sort":{
    "prefix":"heapSort",
    "body":[
        "void heapify(int arr[], int n, int i) ",
"{ ",
"int largest = i; ",
"int l = 2*i + 1; ",
"int r = 2*i + 2;",
"if (l < n && arr[l] > arr[largest]) ",
"largest = l; ",
"if (r < n && arr[r] > arr[largest])",
"largest = r; ",
"if (largest != i) ",
"{ ",
"swap(arr[i], arr[largest]); ",
"heapify(arr, n, largest); ",
"} ",
"} ",
"void buildheap(int arr[],int n){",
"    for (int i = n / 2 - 1; i >= 0; i--)", 
"heapify(arr, n, i);",
"}",
"void heapSort(int arr[], int n) ",
"{  ",
"buildheap(arr,n); ",
"for (int i=n-1; i>0; i--) ",
"{ ",
"swap(arr[0], arr[i]);",
"heapify(arr, i, 0); ",
"} ",
"} ",

    ],
    "description": "Sort array using Heap sort",
},

"Count sort":{
    "prefix":"countSort",
    "body":[

        "void countingSort(int arr[], int n, int exp) ",
"{ ",
 "   int output[n];  ",
 "   int count[10] = { 0 }; ",
 "   for (int i = 0; i < n; i++) ",
 "       count[(arr[i] / exp) % 10]++; ",
 "   for (int i = 1; i < 10; i++) ",
 "       count[i] += count[i - 1]; ",
 "   for (int i = n - 1; i >= 0; i--) { ",
 "       output[count[(arr[i] / exp) % 10] - 1] = arr[i]; ",
 "       count[(arr[i] / exp) % 10]--; ",
 "   } ",
 "   for (int i = 0; i < n; i++) ",
 "       arr[i] = output[i]; ",
"}  ",


    ],
    "description": "Sort array using Count sort",
},

"Radix sort":{
    "prefix":"radixSort",
    "body":[
        "void countingSort(int arr[], int n, int exp) ",
"{ ",
 "   int output[n];  ",
 "   int count[10] = { 0 }; ",
 "   for (int i = 0; i < n; i++) ",
 "       count[(arr[i] / exp) % 10]++; ",
 "   for (int i = 1; i < 10; i++) ",
 "       count[i] += count[i - 1]; ",
 "   for (int i = n - 1; i >= 0; i--) { ",
 "       output[count[(arr[i] / exp) % 10] - 1] = arr[i]; ",
 "       count[(arr[i] / exp) % 10]--; ",
 "   } ",
 "   for (int i = 0; i < n; i++) ",
 "       arr[i] = output[i];", 
"}  ",
"void radixsort(int arr[], int n)", 
"{ ",
 "   int mx = arr[0]; ",
 "   for (int i = 1; i < n; i++)", 
 "       if (arr[i] > mx) ",
 "           mx = arr[i]; ",
 "   for (int exp = 1; mx / exp > 0; exp *= 10) ",
 "       countingSort(arr, n, exp); ",
"} ",

    ],
    "description": "Sort array using Radix sort",
},

"Bucket sort":{
    "prefix":"bucketSort",
    "body":[
        "void bucketSort(int arr[], int n, int k) ",
"{ ",
 "   int max_val=arr[0];",
 "   for(int i=1;i<n;i++)",
 "       max_val=max(max_val,arr[i]);",   
  "  max_val++;     ",
 "   vector<int> bkt[k]; ",
 "   for (int i = 0; i < n; i++) { ",
 "       int bi = (k * arr[i])/max_val; ",
 "       bkt[bi].push_back(arr[i]); ",
  "  } ",
 "   for (int i = 0; i < k; i++) ",
"        sort(bkt[i].begin(), bkt[i].end()); ",
 "   int index = 0; ",
 "   for (int i = 0; i < k; i++) ",
 "       for (int j = 0; j < bkt[i].size(); j++) ",
 "           arr[index++] = bkt[i][j]; ",
"} ",
 

    ],
    "description": "Sort array using bucket sort",
},

/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/

/** -----------------------------------------------------------------------------------------------------------------------------------------------------*/
/**                                            Tree Traversals,Algorithms & views                                                                              */

"Inorder Traversal":{
"prefix":"inorderTraversal",
"body":[

],
"description": "Inorder Traversal of tree",
},

"Preorder Traversal":{
"prefix":"preorderTraversal",
"body":[

],
"description": "Preorder Traversal of tree",
},
"Postorder Traversal":{
"prefix":"postorderTraversal",
"body":[

],
"description": "Postorder Traversal of tree",
},
"Inorder Traversal Iterative":{
"prefix":"inorderTraversalIterative",
"body":[

],
"description": "Inorder Traversal of tree(Iterative)",
},

"Preorder Traversal Iterative":{
"prefix":"preorderTraversalIterative",
"body":[

],
"description": "Preorder Traversal of tree(Iterative)",
},
"Postorder Traversal Iterative":{
"prefix":"postorderTraversalIterative",
"body":[

],
"description": "Postorder Traversal of tree(Iterative)",
},
"Levelorder Traversal ":{
"prefix":"levelorderTraversal",
"body":[

],
"description": "levelorder Traversal of tree",
},
"Morris Traversal ":{
"prefix":"morrisTraversal",
"body":[

],
"description": "morris Traversal of tree",
},
"Diagonal Traversal ":{
"prefix":"diagonalTraversal",
"body":[

],
"description": "diagonalTraversal of tree",
},
"Vertical Width ":{
"prefix":"verticalWidth",
"body":[

],
"description": "Vertical Width of tree",
},
"Diameter Of Tree ":{
"prefix":"diameterOfTree",
"body":[

],
"description": "Diameter Of Tree",
},

"LCA of binary tree ":{
"prefix":"LCA",
"body":[

],
"description": "lowest common ancestor",
},
"Top view of binary tree ":{
"prefix":"topView",
"body":[

],
"description": "top view of binary tree",
},
"left view of binary tree ":{
"prefix":"leftView",
"body":[

],
"description": "left view of binary tree",
},
"right view of binary tree ":{
"prefix":"rightView",
"body":[

],
"description": "right view of binary tree",
},
"bottom view of binary tree ":{
"prefix":"bottomView",
"body":[

],
"description": "bottom view of binary tree",
}
/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/

/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/
/**                                                                          Stacks                                                                     */


/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/
}


            