{
    "template":{
        "prefix":"template",
        "body":[
            " #include \"bits/stdc++.h\" ",
" #include <ext/pb_ds/assoc_container.hpp>",
" #include <ext/pb_ds/tree_policy.hpp> ",
" using namespace std;",
" using namespace __gnu_pbds;",
" #define int              long long",
" #define ps(x,y)         fixed<<setprecision(y)<<x //how much precision is required",
" #define max(x,y)        ((x>y)?x:y)",
" #define min(x,y)        ((x<y)?x:y)",
" #define ff              first",
" #define ss              second",
" #define pb              push_back",
" #define eb              emplace_back",
" #define mp              make_pair",
" #define vi              vector<int>",
" #define vvi             vector<vector<int>>",
" #define pii             pair<int,int>",
" #define all(x)          x.begin(), x.end()",
" #define mem1(a)           memset(a,-1,sizeof(a))",
" #define mem0(a)           memset(a,0,sizeof(a))",
" #define loop(i,a,b)           for(int i=(int)a;i<(int)b;++i)",
" #define bloop(i,a,b)          for(int i=(int)a;i<=(int)b;++i)",
" #define loopr(i,a,b)          for(int i=(int)a;i>=(int)b;--i)",
" #define setbits(x)      __builtin_popcountll(x)",
" #define zrobits(x)      __builtin_ctzll(x)",
" #define uniq(v)           (v).erase(unique(all(v)),(v).end())",
" #define PI 3.1415926535897932384626",
" const int mod = 1000000007;",
" #define debug1(x) cout<<#x<<\" \"<<x<<endl;",
" #define debug2(x,y) cout<<#x<<\" \"<<x<<\" \"<<#y<<\" \"<<y<<endl;",
" #define debug3(x,y,z) cout<<#x<<\" \"<<x<<\" \"<<#y<<\" \"<<y<<\" \"<<#z<<\" \"<<z<<endl;",
" #define debug4(x,y,z,p) cout<<#x<<\" \"<<x<<\" \"<<#y<<\" \"<<y<<\" \"<<#z<<\" \"<<z<<\" \"<<#p<<endl;",
" int modpow(int a, int b, int mod) { int res = 1; for (; b; b >>= 1) { if (b & 1)res = res * a; res %= mod; a = a * a; a %= mod; }return res; }",
" int p(int a, int b) { int res = 1; for (; b; b >>= 1) { if (b & 1)res = res * a; a = a * a; }return res; }",
" typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> pbds; ",
" void ash(){",
"ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
"#ifndef ONLINE_JUDGE",
"   freopen(\"in.txt\", \"r\", stdin);",
"   freopen(\"out.txt\", \"w\", stdout);",
"    #endif ",
" }",
" int countDigit(long long n) {",
"   return floor(log10(n) + 1);",
" }",
" void solve(){",





" }",
" int32_t main()",
" {",
"//ash();",
"int t=1;",
"cin>>t;",
"while(t--){",
"solve();",
"}",
"return 0;",

    
" }",            
        ]
    },
    "Check if a number if power of 2 or not":{
        "prefix":"powerof2",
        "body":[
            "bool isPowerof2(int n){",
                "return (!n&(n-1) && n);",
            "}"
        ],
        "description": "to check if a number is power of 2 or not"
    },
    "bfs traversal of graph":{
        "prefix":"bfs",
        "body":[

            "void bfsUtil(vector<vector<int>> &adj,int i,int v,int e,vector<bool> &visited)",
            "{",
                "queue<int> q;",
                "q.push(i);",
                "visited[i]=true;",
                "cout<<i<<\" \";",
                "while(!q.empty())",
                "{",
                    "int temp=q.front();",
                    "q.pop();",
                    "cout<<temp<<\" \";",
                    "for(auto it=adj[temp].begin();it!=adj[temp].end();it++)",
                    "{",
                        "if(visited[*it]==false)",
                        "{",
                            "q.push(*it);",
                            "visited[*it]=true;",
                        "}",
                    "}",
                "}",
            "}",

            "void bfs(vector<vector<int>> adj,int v,int e)",
            "{",
                "vector<bool> visited(v,false);",
                "for(int i=0;i<v;i++)",
                "if(!visited[i])",
                "bfsUtil(adj,i,v,e,visited);",
            "}"
        ],
        "description": "it prints the bfs traversal of the graph if the graph is given in adjacency list."
    },

    "dfs traversal of graph":{
        "prefix":"dfs",
        "body": [

            "void dfsUtil(vector<vector<int>> adj,int i,int v,int e)",
            "{",
                 "cout<<i<<\" \";",
                 "visited[i]=true;",
                 "for(auto it=adj[temp].begin();it!=adj[temp].end();it++)",
                 "{",
                     "if(visited[*it]==false)",
                     "dfsUtil(adj,*it,v,e,visited);",
                 "}",
            "}",

            "void dfs(vector<vector<int>> adj,int v,int e)",
            "{",
                "vector<bool> visited(v,false);",
                "for(int i=0;i<v;i++)",
                "if(!visited[i])",
                "dfsUtil(adj,i,v,e,visited);",
            "}"
        ],
        "description": "it gives the dfs traversal of the graph provided the graph in adjacency list and the no of vertices and edges"
    },
    "Detect Cycle in Undirected":{
        "prefix":"detectCycleinUndirected",
        "body": [

            "int findd(vector<int> &parent,int i)",
            "{",
                "return parent[i]<0 ? i:parent[i]=findd(parent,parent[i]);",
            "}",

            "void unionn(vector<int> &parent,int x,int y)",
            "{",
                "if(parent[x]>parent[y])",
                "swap(x,y);",
                "parent[x]+=parent[y];",
                "parent[y]=x;",
            "}",

            "bool findCycle(vector<pair<int,int>> adj,int v,int e)",
            "{",
                "vector<int> parent(v,-1);",
                "for(int i=0;i<e;i++)",
                "{",
                    "int x=findd(parent,adj[i].first);",
                    "int y=findd(parent,adj[i].second);",
                    "if(x!=y)",
                    "{",
                        "unionn(parent,x,y)",
                    "}",
                    "else{",
                        "return 0;",
                    "}",
                "}",
                "return 1;",
            "}",
        ],
        "description": "detect whether the undirected graph contains cycle or not provided the graph as an array of edges (vector of pairs) , vertices, edges"
    },
    "Detect Cycle in Directed":{
        "prefix":"detectCycleinDirected",
        "body": [

            "bool isCycleUtil(vector<vector<int>> &adj,vector<int> &visited,vector<int> &recStack,int i)",
            "{",
                "if(visited[i]==false)",
                "{",
                    "visited[i]=true;",
                    "recStack[i]=true;",
                    "for(auto it=adj[i].begin();it!=adj[i].end();it++){",
                        "if(recStack[*it])",
                        "return true;",
                        "else if(!visited[*it] && isCycleutil(adj,visited,recStack,*it))",
                        "return true;",
                    "}",
                "}",
                "recStack[i]=false;",
                "return false;",
            "}",

            "bool isCycle(vector<vector<int>> &adj,int v,int e)",
            "{",
                "vector<int> visited(v,false);",
                "vector<int> recStack(v,false);",
                "for(int i=0;i<v;i++){",
                    "if(isCycleUtil(adj,visited,recStack,i))",
                    "return 1;",
                "}",
                "return 0;",
            "}",
        ]
    },
    "kruskal minimum spanning tree":{
            "prefix":"kruskal",
            "body":[
                "int findd(vector<int> &parent,int i){",
                    "return parent[i]<0 ? i:parent[i]=findd(parent,parent[i]);",
                "}",

                "void unionn(vector<int> &parent,int x,int y)",
                "{",
                    "if(parent[x]>parnet[y])",
                    "swap(x,y);",
                    "parent[x]+=parnet[y];",
                    "parnet[y]=x;",
                "}",

                "int mst(vector<pair<pair<int,int>>> adj,int v,int e){",
                    "int ans=0;",
                    "vector<int> parnet(v,-1);",
                    "sort(adj.begin(),adj.end());",
                    "for(int i=0;i<e;i++){",
                        "int from=adj[i].second.first;",
                        "int to=adj[i].second.second;",
                        "int w=adj[i].first;",
                        "int x=findd(parent,from);",
                        "int y=findd(parent,to);",
                        "if(x!=y)",
                        "{",
                            "ans+=w;",
                            "unionn(parent,x,y);",
                        "}",
                    "}",
                    "return ans;",
                "}",
            ],
            "desciption":"to find the minimum spanning tree of a graph provided(graph as pair of pair {weight,{from,to}}) ,vertices,edges",
        },
            "prims minimum spanning tree":{
                "prefix":"prims",
                "body":[

                    "int findd(vector<bool> &mstSet,vector<int> &dist){",
                        "int mini=INT_MAX,vertex;",
                        "for(int i=0;i<dist.size();i++){",
                            "if(dist[i]<mini && mstSet[i]==false){",
                                "mini=dist[i];",
                                "vertex=i;",
                            "}",
                        "}",
                        "return vertex;",
                    "}",

                    "int mst(vector<vector<int>> &adj,int v,int e)",
                    "{",
                        "vector<int> dist(v,INT_MAX);",
                        "vector<int> parent(v);",
                        "vector<bool> mstSet(v,false);",
                        "dist[0]=0;",
                        "parent[0]=-1;",
                        
                        "for(int i=0;i<v-1;i++)",
                        "{",
                            "int vertex=findd(mstSet,dist);",
                            "mstSet[vertex]=true;",
                            "for(int j=0;j<v;j++){",
                                "if(adj[vertex][j]!=0 && mstSet[j]==false && dist[j]>adj[vertex][j])",
                                "{",
                                    "dist[j]=adj[vertex][j];",
                                    "parent[j]=vertex;",
                                "}",
                            "}",
                        "}",
                        "int ans=0;",
                        "for(int i=1;i<v;i++){",
                            "ans+=adj[parent[i]][i];",
                        "}",
                        "return ans;",
                    "}",
                ],
                "description": "to find the minimum spanning tree using prims algo provided (graph as adjacency matrix ,vertices and edges)",
            },
/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/
/**                                                     Sorting Algorithms                                                */
            "bubble sort":{
                "prefix":"bubbleSort",
                "body":[
                    "void bubbleSort(vector<int> &a){",
                    "int n=a.size();",

             " for(int i=0;i<n-1;i++)",
             "{",
               "  int flag=0;",
               " for(int j=0;j<n-i-1;j++){",
               "  if(a[j]>a[j+1]){",
               "   swap(a[j],a[j+1]);",
               "  ++flag;",
             "}",

              "}",
            "if(flag==0) break;",
             "}",
              "for(int i=0;i<a.size();i++){",
             " cout<<a[i]<<\" \";",
             "}",
             "}",

                ],
                "description": "Sort array using bubble sort",
            },

            "selection sort":{
                "prefix":"selectionSort",
                "body":[
                    "void selectionSort(vector<int> &a){",
"    int n=a.size();",
"    for(int i = 0; i < n; i++){",
"        int min_ind = i;",    
"        for(int j = i + 1; j < n; j++){",
"            if(a[j] < a[min_ind]){",
"                min_ind = j;",
"            }",
"        }",    
"        swap(a[i], a[min_ind]);",
"    }",
"    for(int i=0;i<a.size();i++){",
"  cout<<a[i]<<\" \";",
"}",
"}",


                ],
                "description": "Sort array using selection sort",
            },

            "Insertion sort":{
                "prefix":"insertionSort",
                "body":[
                    "void iSort(vector<int>&a){",
"   int n=a.size();",
"   for(int i=1;i<n;i++){",
"       int key = a[i];",
"        int j=i-1;",
"        while(j>=0 && a[j]>key){",
"            a[j+1]=a[j];",
"            j--;",
"        }",
"        a[j+1]=key;",
"    }",
"        for(int i=0;i<a.size();i++){",
"  cout<<a[i]<<\" \";",
"}",
"}",

                ],
                "description": "Sort array using Insertion sort",
            },

            "Merge sort":{
                "prefix":"mergeSort",
                "body":[

                ],
                "description": "Sort array using Merge sort",
            },

            "Quick sort":{
                "prefix":"quickSort",
                "body":[

                ],
                "description": "Sort array using Quick sort",
            },

            "Heap sort":{
                "prefix":"heapSort",
                "body":[

                ],
                "description": "Sort array using Heap sort",
            },
            "Quick sort tail optimised":{
                "prefix":"quickSort(tailOptimised)",
                "body":[

                ],
                "description": "Sort array using quick sort(tail optimised)",
            },

            "Count sort":{
                "prefix":"countSort",
                "body":[

                ],
                "description": "Sort array using Count sort",
            },

            "Radix sort":{
                "prefix":"radixSort",
                "body":[

                ],
                "description": "Sort array using Radix sort",
            },

            "Bucket sort":{
                "prefix":"bucketSort",
                "body":[

                ],
                "description": "Sort array using bucket sort",
            },

/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/

/** -----------------------------------------------------------------------------------------------------------------------------------------------------*/
/**                                            Tree Traversals,Algorithms & views                                                                              */

"Inorder Traversal":{
    "prefix":"inorderTraversal",
    "body":[

    ],
    "description": "Inorder Traversal of tree",
},

"Preorder Traversal":{
    "prefix":"preorderTraversal",
    "body":[

    ],
    "description": "Preorder Traversal of tree",
},
"Postorder Traversal":{
    "prefix":"postorderTraversal",
    "body":[

    ],
    "description": "Postorder Traversal of tree",
},
"Inorder Traversal Iterative":{
    "prefix":"inorderTraversalIterative",
    "body":[

    ],
    "description": "Inorder Traversal of tree(Iterative)",
},

"Preorder Traversal Iterative":{
    "prefix":"preorderTraversalIterative",
    "body":[

    ],
    "description": "Preorder Traversal of tree(Iterative)",
},
"Postorder Traversal Iterative":{
    "prefix":"postorderTraversalIterative",
    "body":[

    ],
    "description": "Postorder Traversal of tree(Iterative)",
},
"Levelorder Traversal ":{
    "prefix":"levelorderTraversal",
    "body":[

    ],
    "description": "levelorder Traversal of tree",
},
"Morris Traversal ":{
    "prefix":"morrisTraversal",
    "body":[

    ],
    "description": "morris Traversal of tree",
},
"Diagonal Traversal ":{
    "prefix":"diagonalTraversal",
    "body":[

    ],
    "description": "diagonalTraversal of tree",
},
"Vertical Width ":{
    "prefix":"verticalWidth",
    "body":[

    ],
    "description": "Vertical Width of tree",
},
"Diameter Of Tree ":{
    "prefix":"diameterOfTree",
    "body":[

    ],
    "description": "Diameter Of Tree",
},

"LCA of binary tree ":{
    "prefix":"LCA",
    "body":[

    ],
    "description": "lowest common ancestor",
},
"Top view of binary tree ":{
    "prefix":"topView",
    "body":[

    ],
    "description": "top view of binary tree",
},
"left view of binary tree ":{
    "prefix":"leftView",
    "body":[

    ],
    "description": "left view of binary tree",
},
"right view of binary tree ":{
    "prefix":"rightView",
    "body":[

    ],
    "description": "right view of binary tree",
},
"bottom view of binary tree ":{
    "prefix":"bottomView",
    "body":[

    ],
    "description": "bottom view of binary tree",
}
/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/

/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/
/**                                                                          Stacks                                                                     */


/**-----------------------------------------------------------------------------------------------------------------------------------------------------*/
} 